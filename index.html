<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RaidCode Void – Echo Images from the Shadows</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            background: #000; 
            color: #1a1a1a; 
            font-family: 'Courier New', monospace; 
            overflow: hidden; 
            height: 100vh; 
            cursor: none; /* Void Cursor */
        }
        .void-container { position: relative; width: 100%; height: 100%; }
        .shadow-layer { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: radial-gradient(circle at 50% 50%, rgba(0,0,0,0.98) 0%, #000 80%); 
            animation: voidBreathe 10s ease-in-out infinite; 
            opacity: 1; transition: opacity 1s;
        }
        @keyframes voidBreathe { 
            0%, 100% { transform: scale(1); opacity: 0.99; } 
            50% { transform: scale(1.01); opacity: 0.97; } 
        }
        .echo-text { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            font-size: 2em; color: rgba(255,255,255,0.05); 
            text-shadow: 0 0 15px rgba(255,255,255,0.02); 
            transition: all 1s; opacity: 0; 
            pointer-events: none;
        }
        .echo-text.reveal { opacity: 0.6; color: rgba(255,255,255,0.2); transform: translate(-50%, -50%) scale(1.05); }
        .connect-gate { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            background: rgba(0,0,0,0.98); border: 1px solid rgba(255,255,255,0.05); 
            padding: 25px; border-radius: 0; text-align: center; z-index: 3; 
            opacity: 0; transition: opacity 1s; max-width: 350px; 
        }
        .connect-gate.active { opacity: 1; }
        .connect-btn { background: rgba(255,255,255,0.08); color: #fff; border: 1px solid rgba(255,255,255,0.1); padding: 10px 20px; cursor: pointer; font-family: inherit; transition: all 0.4s; border-radius: 0; }
        .connect-btn:hover { background: rgba(255,255,255,0.15); box-shadow: 0 0 8px rgba(255,255,255,0.2); }
        .wallet-status { position: absolute; top: 10px; right: 10px; color: rgba(255,255,255,0.2); font-size: 0.8em; opacity: 0; transition: opacity 0.5s; }
        .wallet-status.oathed { opacity: 1; color: rgba(0,255,0,0.4); }
        .image-void { position: absolute; opacity: 0; transition: opacity 1.5s, transform 1.5s; transform: scale(0.8); z-index: 2; width: 200px; height: 200px; object-fit: cover; border-radius: 10px; border: 1px solid rgba(255,255,255,0.1); }
        .image-void.reveal { opacity: 0.7; transform: scale(1); }
        .image-void:hover { opacity: 1; transform: scale(1.1); filter: hue-rotate(180deg) brightness(1.2); box-shadow: 0 0 20px rgba(255,255,255,0.3); }
        /* Procedural Image Styles (Open-Source Fractals – Math-Generated) */
        .fractal-img { background: linear-gradient(45deg, #111, #222); position: relative; overflow: hidden; }
        .fractal-img::before { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: repeating-linear-gradient(45deg, transparent 0, transparent 10px, rgba(255,255,255,0.05) 10px, rgba(255,255,255,0.05) 20px); animation: fractalShift 5s linear infinite; }
        @keyframes fractalShift { 0% { transform: translateX(0); } 100% { transform: translateX(-20px); } }
        /* Mobile */
        @media (max-width: 768px) { .echo-text { font-size: 1.5em; } .connect-gate { padding: 15px; max-width: 90%; } .image-void { width: 150px; height: 150px; } }
    </style>
</head>
<body>
    <div class="void-container">
        <div class="shadow-layer" id="shadowLayer"></div>
        
        <div class="echo-text" id="echo1">RaidCode Void</div>
        <div class="echo-text" id="echo2">Image Echoes Emerge</div>
        <div class="echo-text" id="echo3">Connect to Decode</div>
        
        <div class="connect-gate" id="connectGate">
            <h2>Pierce the Void</h2>
            <p>Connect wallet to reveal the shadows. Images whisper from the code.</p>
            <button class="connect-btn" onclick="enterVoid()">Connect Wallet</button>
            <div class="wallet-status" id="walletEcho">Silent – Connect for Echo</div>
        </div>
        
        <!-- 7 Procedural Image Voids (Open-Source Math Fractals, Inspired by Attachments) -->
        <div class="image-void fractal-img" id="voidImg1" style="top: 20%; left: 10%;"></div>
        <div class="image-void fractal-img" id="voidImg2" style="top: 30%; right: 15%;"></div>
        <div class="image-void fractal-img" id="voidImg3" style="bottom: 40%; left: 20%;"></div>
        <div class="image-void fractal-img" id="voidImg4" style="top: 60%; right: 25%;"></div>
        <div class="image-void fractal-img" id="voidImg5" style="bottom: 20%; left: 5%;"></div>
        <div class="image-void fractal-img" id="voidImg6" style="top: 10%; left: 70%;"></div>
        <div class="image-void fractal-img" id="voidImg7" style="bottom: 30%; right: 10%;"></div>
    </div>

    <script>
        // State: Void Layers for Mystery
        let voidLevel = 0;
        const maxLevel = 3; // Simplified: Void → Connect → Full Reveal → Infinite Fades
        let walletConnected = false;
        let walletAddress = '';
        const echoes = ['Void Opens.', 'Images Breathe.', 'Shadows Decode.', 'Echoes Eternal.'];

        // Procedural Image Generation (Open-Source Math – 7 Fractals, Cyberpunk-Inspired from Attachments)
        function generateProceduralImage(id) {
            const canvas = document.createElement('canvas');
            canvas.width = 200;
            canvas.height = 200;
            const ctx = canvas.getContext('2d');
            
            // Math Fractal Base (Mandelbrot-Style for Mystery, Open-Source Algos)
            const imageData = ctx.createImageData(200, 200);
            const data = imageData.data;
            for (let x = 0; x < 200; x++) {
                for (let y = 0; y < 200; y++) {
                    let real = (x - 100) / 50;
                    let imag = (y - 100) / 50;
                    let cr = real;
                    let ci = imag;
                    let zReal = 0, zImag = 0;
                    let iter = 0;
                    const maxIter = 50;
                    while (iter < maxIter && (zReal * zReal + zImag * zImag) < 4) {
                        let temp = zReal * zReal - zImag * zImag + cr;
                        zImag = 2 * zReal * zImag + ci;
                        zReal = temp;
                        iter++;
                    }
                    // Cyberpunk Neon Colors (Inspired by Attachments – Open-Source Palette)
                    const color = iter === maxIter ? [0, 0, 0, 255] : [iter * 5 % 255, iter * 3 % 255, 255 - iter * 2 % 255, 255];
                    const idx = (y * 200 + x) * 4;
                    data[idx] = color[0];     // R
                    data[idx + 1] = color[1]; // G
                    data[idx + 2] = color[2]; // B
                    data[idx + 3] = color[3]; // A
                }
            }
            ctx.putImageData(imageData, 0, 0);
            
            // Add Neon Edge (Attachment Vibe – Open-Source Filter)
            ctx.filter = 'contrast(1.5) saturate(2)';
            ctx.drawImage(canvas, 0, 0);
            
            return canvas.toDataURL('image/png'); // Procedural PNG
        }

        // Pre-Generate 7 Open-Source Images (Math Fractals)
        const proceduralImages = [];
        for (let i = 1; i <= 7; i++) {
            proceduralImages[i] = generateProceduralImage(i);
        }

        // Enter Void (Wallet Connect – Simple Stub)
        function enterVoid() {
            if (typeof window.solana !== 'undefined' && window.solana.isPhantom) {
                window.solana.connect().then((response) => {
                    walletAddress = response.publicKey.toString();
                    walletConnected = true;
                    document.getElementById('walletEcho').textContent = `Echo: ${walletAddress.slice(0,8)}...`;
                    document.getElementById('walletEcho').classList.add('oathed');
                    document.getElementById('connectGate').classList.remove('active');
                    revealEchoes();
                    if (navigator.vibrate) navigator.vibrate(100); // Subtle Void Pulse
                }).catch(() => alert('Void Rejects – Install Phantom.'));
            } else {
                alert('No Phantom – Void Remains Sealed.');
            }
        }

        // Reveal Echoes (Images Fade In on Connect)
        function revealEchoes() {
            voidLevel = 1;
            document.querySelectorAll('.echo-text').forEach((echo, i) => {
                setTimeout(() => echo.classList.add('reveal'), i * 500);
            });
            document.querySelectorAll('.image-void').forEach((img, i) => {
                img.src = proceduralImages[i + 1];
                setTimeout(() => {
                    img.classList.add('reveal');
                    img.style.top = (20 + i * 10) + '%';
                    img.style.left = (10 + (i % 3) * 30) + '%';
                }, i * 300);
            });
            // Infinite Fade Cycle (Retention: Endless Subtle Shifts)
            setInterval(() => {
                proceduralImages.forEach((imgData, i) => {
                    const canvas = document.createElement('canvas');
                    canvas.width = 200;
                    canvas.height = 200;
                    const ctx = canvas.getContext('2d');
                    const tempImg = new Image();
                    tempImg.onload = () => {
                        ctx.drawImage(tempImg, 0, 0);
                        // Subtle Glitch Filter (Math Shift)
                        ctx.filter = `hue-rotate(${Math.sin(Date.now() / 1000 + i) * 180}deg)`;
                        ctx.drawImage(canvas, 0, 0);
                        document.getElementById(`voidImg${i + 1}`).src = canvas.toDataURL('image/png');
                    };
                    tempImg.src = imgData;
                });
            }, 3000); // 3s Cycle – Hypnotic, Not Overwhelming
        }

        // Mouse Void Interaction (Hover Reveals Layers)
        document.addEventListener('mousemove', (e) => {
            if (!walletConnected) return;
            const x = e.clientX / window.innerWidth;
            const y = e.clientY / window.innerHeight;
            // Shift Shadow Layers (Mystery Depth)
            document.getElementById('shadowLayer').style.transform = `translate(${x * 10 - 5}px, ${y * 10 - 5}px) scale(1.01)`;
            // Image Hover Glitch (Decode Effect)
            document.querySelectorAll('.image-void').forEach((img, i) => {
                const dist = Math.sqrt((x - 0.5) ** 2 + (y - 0.5) ** 2);
                if (dist < 0.2) {
                    img.style.filter = 'brightness(1.5) contrast(1.2)';
                    img.style.opacity = 1;
                    // Whisper on Close Hover
                    if (i === 0) document.getElementById('echo3').textContent = 'Echo Decoded – Image ${i+1} Whispers.';
                } else {
                    img.style.filter = 'none';
                }
            });
        });

        // Infinite Void Cycle (Retention: Endless Mystery)
        let cycleIndex = 0;
        setInterval(() => {
            cycleIndex++;
            document.querySelectorAll('.echo-text').forEach((echo, i) => {
                echo.textContent = echoes[(cycleIndex + i) % echoes.length];
                if (walletConnected) echo.classList.add('reveal');
            });
            // Level Up Tease (Subtle, No Bounties – Just Deeper Voids)
            if (walletConnected && cycleIndex % 5 === 0) {
                voidLevel = Math.min(voidLevel + 1, maxLevel);
                document.querySelector('.shadow-layer').style.opacity = 0.9 - voidLevel * 0.05;
                alert(`Void Level ${voidLevel}: Deeper Echoes Emerge – Return for More Images.`);
            }
        }, 5000); // 5s Cycles – Slow Mystery Build

        // Init: Show Gate
        window.onload = () => {
            setTimeout(() => document.getElementById('connectGate').classList.add('active'), 1000); // Delayed Void Reveal
            // Pre-Load Procedural Images (Open-Source Math)
            proceduralImages.forEach((imgData, i) => {
                const tempImg = new Image();
                tempImg.src = imgData;
            });
        };
    </script>
</body>
</html>
